
/* 归并排序为稳定排序: 平均、最好、最坏时间复杂度 O( n ),
 * 空间复杂度 O( nlog^2 n )
 */

/* -----------------------------------------------------------  */
/* 相关接口  */
#include <stdio.h>
#include <stdlib.h>
/* -----------------------------------------------------------  */


/* -----------------------------------------------------------  */
/* 相关特殊宏  */
#define MAXSIZE 10

#if 0
// 注释
	#define swap( arr, j, i ) { \
	int tmp = 0; tmp = arr[ i ]; \
	arr[ i ] = arr[ j ]; arr[ j ] = tmp; }
#endif
/* -----------------------------------------------------------  */


/* -----------------------------------------------------------  */
/* 全局  */
int arr_1[ MAXSIZE ] = { 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 };
int arr_2[ MAXSIZE ] = { 5, 4, 6, 9, 8, 7, 2, 0, 1, 4 };
/* -----------------------------------------------------------  */


/* ------------------------------------------------------------------------------------------------------------------------------  */
void BeforeMergeSortRecursion( int *arr, int n );         /* 递归归并排序前                                                        */
void BeforeMergeSortIteration( int *arr, int n );         /* 迭代归并排序前（非递归）                                              */
void Merge( int *arr, int mid, int left, int right );     /* 合并两个已排好序的子数组索引 A[ left...mid ] 与 A[ mid + 1...right ]  */
void MergeSortRecursion( int *arr, int left, int right ); /* 递归归并                                                              */
void MergeSortIteration( int *arr, int len );             /* 迭代归并（非递归）                                                    */
void PrintRecursiveMergeData( int *arr, int n );          /* 打印递归归并结果                                                      */
void PrintNon_recursiveMergeData( int *arr, int n );      /* 打印迭代归并结果（非递归）                                            */
/* ------------------------------------------------------------------------------------------------------------------------------  */


/* ------------------------------------------------------------------------------------------------------------------------------  */
/* 主测试  */
int main( int argc, char **argv )
{
	BeforeMergeSortRecursion( arr_1, sizeof( arr_1 ) / sizeof( int ) );
    MergeSortRecursion( arr_1, 0, sizeof( arr_1 ) / sizeof( int ) - 1 );   /* 递归排序            */
    BeforeMergeSortIteration( arr_2, sizeof( arr_2 ) / sizeof( int ) );
    MergeSortIteration( arr_2, sizeof( arr_2 ) / sizeof( int ) );          /* 非递归排序          */
    PrintRecursiveMergeData( arr_1, sizeof( arr_2 ) / sizeof( int ) );     /* 打印递归归并结果    */
    PrintNon_recursiveMergeData( arr_2, sizeof( arr_2 ) / sizeof( int ) ); /* 打印非递归归并结果  */
    
    system("pause");
    return 0;
}
/* ------------------------------------------------------------------------------------------------------------------------------  */


/* ------------------------------------------------------------------------------------------------------------------------------  */
/* 递归归并排序前  */
void BeforeMergeSortRecursion( int *arr, int n ) {
	printf( "递归归并排序前:     " );
    for ( int i = 0; n > i; ++i )
        printf( "%d ", arr[ i ] );
    putchar( '\n' );
}
/* ------------------------------------------------------------------------------------------------------------------------------  */


/* ------------------------------------------------------------------------------------------------------------------------------  */
/* 迭代归并排序前（非递归）  */
void BeforeMergeSortIteration( int *arr, int n ) {
	printf( "非递归归并排序前:   " );
    for ( int i = 0; n > i; ++i )
        printf( "%d ", arr[ i ] );
    putchar( '\n' );
}
/* ------------------------------------------------------------------------------------------------------------------------------  */


/* ------------------------------------------------------------------------------------------------------------------------------  */
/* 合并两个已排好序的子数组索引 A[ left...mid ] 与 A[ mid + 1...right ]  */
void Merge( int *arr, int mid, int left, int right ) {
	int i      = left, j = 1 + mid; /* 左、右边各一半起始元素  */
	int len    = right - left + 1;  /* 使右边另外一半减去往左边的 n + 1 个元素得到的长度  */
    int *iTemp = new int[ len ];    /* 辅助空间    */
    int index  = 0;                 /* 记录索引值  */
    
    while ( ( i <=  mid ) && ( j <= right ) )
		iTemp[ index++ ] = ( arr[ i ] <= arr[ j ] ? arr[ i++ ] : arr[ j++ ] );
		
	/* 判断左边一半  */
    while ( i <= mid ) 
        iTemp[ index++ ] = arr[ i++ ]; /* 每次遍历索引并右移一位  */
        
	/* 判断右边一半  */
    while ( j <= right )
        iTemp[ index++ ] = arr[ j++ ];

    for ( int i = 0; len > i; ++i )
        arr[ left++ ] = iTemp[ i ];
}
/* ------------------------------------------------------------------------------------------------------------------------------  */


/* ------------------------------------------------------------------------------------------------------------------------------  */
/* 递归归并  */
void MergeSortRecursion( int *arr, int left, int right ) {
	int mid = ( left + right ) / 2; /* 分成一半  */
    if ( left == right )            /* 两边相等, 递归回溯, 调用函数做递归操作  */
		return ;
    MergeSortRecursion( arr, left, mid );
    MergeSortRecursion( arr, mid + 1, right );
    Merge( arr, mid, left, right ); /* 归并数组  */
}
/* ------------------------------------------------------------------------------------------------------------------------------  */


/* ------------------------------------------------------------------------------------------------------------------------------  */
/* 迭代归并（非递归）  */
void MergeSortIteration( int *arr, int len ) {
    int mid = 0, right = 0;
    for ( int i = 1; len > i; i *= 2 ) {               /* 子数组大小 i 初始值为 1, 每次循环翻倍  */
        int left = 0;
        while ( len >= left + i ) {                    /* 后一个子数组存在  */
            mid   = left + i - 1;
            right = mid + i < len ? mid + i : len - 1; /* 后一个子数组大小可能不够  */
            Merge( arr, mid, left, right );
            left  = right + 1;                         /* 前一个子数组索引向后移动  */
        }
    }
}
/* ------------------------------------------------------------------------------------------------------------------------------  */


/* ------------------------------------------------------------------------------------------------------------------------------  */
/* 打印递归归并结果  */
void PrintRecursiveMergeData( int *arr, int n ) {
	printf( "递归归并排序结果:   " );
    for ( int i = 0; n > i; ++i )
        printf( "%d ", arr[ i ] );
    putchar( '\n' );
}
/* ------------------------------------------------------------------------------------------------------------------------------  */


/* ------------------------------------------------------------------------------------------------------------------------------  */
/* 打印迭代归并结果（非递归）  */
void PrintNon_recursiveMergeData( int *arr, int n ) {
	printf( "非递归归并排序结果: " );
    for ( int i = 0; n > i; ++i )
        printf( "%d ", arr[ i ] );
    putchar( '\n' );
}
/* ------------------------------------------------------------------------------------------------------------------------------  */

