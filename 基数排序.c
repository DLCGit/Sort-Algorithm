
/* 基数排序为稳定排序: 平均、最好、最坏时间复杂度 O( d( n + r ) ),
 * 空间复杂度 O( n + r )
 */
 
/* -----------------------------------------------------------------------------------------------------------------  */
/* 相关接口  */
#include <stdio.h>
#include <stdlib.h>
/* -----------------------------------------------------------------------------------------------------------------  */


/* -----------------------------------------------------------------------------------------------------------------  */
/* 特殊宏常量  */
#define NUL     0
#define MAXSIZE 9
/* -----------------------------------------------------------------------------------------------------------------  */


/* -----------------------------------------------------------------------------------------------------------------  */
/* 函数原型  */

/* ( 计数排序 )
 * arr（ 待排数组 ）;
 * brr（ 排序后数组 ）;
 * crr（ 保存 0 ~ n 中每个值出现的次数 ）
 * fet（ 保存从 0 ~ n中取出的值 ）
 * len（ 数组长度 ）
 */
void Count_Sort( int *arr, int *brr, int *crr, int *fet, int n, int len );
void Basic_Sort( int *arr, int *brr, int *crr, int *fet, int n, int len, int dig ); /* 基数排序, 参数 d 为元素的位数  */
void Before_Ordering( int *arr, int n );                                            /* 数组排序前                     */
void After_Ordering( int *arr, int n );                                             /* 数组排序后                     */
/* -----------------------------------------------------------------------------------------------------------------  */


/* -----------------------------------------------------------------------------------------------------------------  */
/* 主测试  */
int main( int argc, char **argv )
{
    /* 待排序数组, 每一个元素的每一位数不能超过 0 - 9 之间  */
    int arr[ MAXSIZE ] = { 31512, 111, 611, 511, 500000, 411, 711, 865, 70000 };
    int brr[ MAXSIZE ]; /* 保存每次计数排序后结果            */
    int fet[ MAXSIZE ]; /* 保存每次遍历该位上的数            */
    int crr[ MAXSIZE ]; /* 保存每次遍历该位上的数出现的次数  */
	
    Before_Ordering( arr, sizeof( arr ) / sizeof( int ) );
    Basic_Sort( arr, brr, crr, fet, MAXSIZE - 1, MAXSIZE, 6 );
    After_Ordering( arr, sizeof( arr ) / sizeof( int ) );
	
#if NUL
	Basic_Sort( ( sizeof( arr ) / sizeof( int ) ), sizeof( brr ) / sizeof( int ),
 	    sizeof( crr ) / sizeof( int ), sizeof( fet ) / sizeof( int ),
	    9, sizeof( arr ) / sizeof( int ), 6 );
#endif
	
    system("pause");
    return 0;
}
/* -----------------------------------------------------------------------------------------------------------------  */


/* -----------------------------------------------------------------------------------------------------------------  */
/* ( 计数排序 )
 * arr（ 待排数组 ）;
 * brr（ 排序后数组 ）;
 * crr（ 保存 0 ~ n 中每个值出现的次数 ）
 * fet（ 保存从 0 ~ n中取出的值 ）
 * len（ 数组长度 ）
 */
void Count_Sort( int *arr, int *brr, int *crr, int *fet, int n, int len ) {
    for ( int i = 0; n >= i; ++i )  /* 将 crr数组 初始化为 0  */
	crr[ i ] = 0;

    for ( int i = 0; len > i; ++i ) /* 统计 fet数组 中每个元素重复出现的个数  */
	crr[ fet[ i ] ]++;

    for ( int i = 1; n >= i; ++i )  /* 求 fet数组 中 <= i 的元素个数  */
	crr[ i ] += crr[ i - 1 ];

    for ( int i = len - 1; i >= 0; --i ) {     /* 将 arr 中元素放到 brr 中对应位置上  */
	brr[ crr[ fet[ i ] ] - 1 ] = arr[ i ];
	crr[ fet[ i ] ]--;                     /* 如果有相同的元素, 则放在下一个位置  */
    }

    for ( int i = 0; len > i ; ++i )/* 再将 brr中的元素复制到 arr, 这样才能达到有序的效果  */
	arr[ i ] = brr[ i ];
}
/* -----------------------------------------------------------------------------------------------------------------  */


/* -----------------------------------------------------------------------------------------------------------------  */
/* 基数排序, 参数 dig 为元素的位数  */
void Basic_Sort( int *arr, int *brr, int *crr, int *fet, int n, int len, int dig ) {
    int val = 1;
    for ( int i = 1; dig >= i; ++i ) {            /* 从低位到高位依次进行计数排序  */
	for ( int j = 0; len > j; ++j )           /* fet 中保存 arr 每个元素对应位上的个数, 范围在 0 ~ n 之间  */
	    fet[ j ] = ( arr[ j ] / val ) % 10;
	Count_Sort( arr, brr, crr, fet, n, len ); /* 对当前位进行计数排序  */
	val *= 10;
    }
}
/* -----------------------------------------------------------------------------------------------------------------  */


/* -----------------------------------------------------------------------------------------------------------------  */
/* 数组排序前  */
void Before_Ordering( int *arr, int n ) {
    printf( "排序前: " );
    for ( int i = 0; MAXSIZE > i; ++i )
	printf( "%d ", arr[ i ] );
    putchar( '\n' );
}
/* -----------------------------------------------------------------------------------------------------------------  */


/* -----------------------------------------------------------------------------------------------------------------  */
/* 数组排序后  */
void After_Ordering( int *arr, int n ) {
    printf( "排序后: " );
    for ( int i = 0; MAXSIZE > i; ++i )
	printf( "%d ", arr[ i ] );
    putchar( '\n' );
}
/* -----------------------------------------------------------------------------------------------------------------  */
